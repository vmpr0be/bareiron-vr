- **Discovered by**: Soulaimane Hafid (suleif) + vmpr0be
- **Severity**: High
- **Impact**: Allows assigning an 8‑bit integer with an arbitrary value, leading to OOB reads
- **Affected versions**: Starting from commit `269e8346ebfb97177f6e11ebd108149920c86fd0`
- **Technical Summary**: The client can set the hotbar field to any user‑controlled integer without validation. Since the player's inventory is ~50 elements, this results in out‑of‑bounds (OOB) accesses throughout the codebase.

- `handlePacket` → `cs_setHeldItem`:
```c
https://github.com/p2r3/bareiron/blob/8e4d4020d7e0797153512768621fba12f0ce68f1/src/packets.c#L809
int cs_setHeldItem (int client_fd) {
...
    player->hotbar = (uint8_t)readUint16(client_fd);S
...
}
```

`handlePlayerAction` does not validate whether `player->hotbar` is within inventory bounds. The previously corrupted index is later used to read or write memory beyond the intended arrays, allowing controlled OOB access of up to 255 bytes.

- `handlePacket` -> `cs_playerAction` -> `handlePlayerAction` -> `sc_setContainerSlot`:
```c
https://github.com/p2r3/bareiron/blob/8e4d4020d7e0797153512768621fba12f0ce68f1/src/packets.c#L459
int sc_setContainerSlot (int client_fd, int window_id, uint16_t slot, uint8_t count, uint16_t item) {
...
    writeVarInt(client_fd, count);
    if (count > 0) {
        writeVarInt(client_fd, item);
...
}

https://github.com/p2r3/bareiron/blob/8e4d4020d7e0797153512768621fba12f0ce68f1/src/procedures.c#L1153
void handlePlayerAction (PlayerData *player, int action, short x, short y, short z) {
...
    if (action == 3 || action == 4) {
        sc_setContainerSlot(
            player->client_fd, 0,
            serverSlotToClientSlot(0, player->hotbar),
            player->inventory_count[player->hotbar], <=== !!!!
            player->inventory_items[player->hotbar] <=== !!!!
        );
        return;
}
...
}
```

Additional uses of `player->hotbar` across the code provide attackers with limited but meaningful manipulation primitives:

```c
void bumpToolDurability (PlayerData *player) {
...
    if (...) {
https://github.com/p2r3/bareiron/blob/8e4d4020d7e0797153512768621fba12f0ce68f1/src/procedures.c#L727
            player->inventory_items[player->hotbar] = 0; <=== !!! OOB nulling
            player->inventory_count[player->hotbar] = 0; <=== !!! OOB nulling
            sc_entityEvent(player->client_fd, player->client_fd, 47);
            sc_setContainerSlot(player->client_fd, 0, serverSlotToClientSlot(0, player->hotbar), 0, 0);
        }
    }

    uint8_t handlePlayerEating (PlayerData *player, uint8_t just_check) {
...
https://github.com/p2r3/bareiron/blob/8e4d4020d7e0797153512768621fba12f0ce68f1/src/procedures.c#L985
    uint16_t *held_item = &player->inventory_items[player->hotbar];
    uint8_t *held_count = &player->inventory_count[player->hotbar];
...
https://github.com/p2r3/bareiron/blob/8e4d4020d7e0797153512768621fba12f0ce68f1/src/procedures.c#L1018
    *held_count -= 1; <=== OOB decrement !!
    if (*held_count == 0) *held_item = 0; <=== !!! OOB nulling
...
https://github.com/p2r3/bareiron/blob/8e4d4020d7e0797153512768621fba12f0ce68f1/src/procedures.c#L1024
    sc_setContainerSlot(
        player->client_fd, 0,
        serverSlotToClientSlot(0, player->hotbar),
        *held_count, *held_item <=== !!!! OOB leaking
    );
```
